---
// Component that creates an interactive D3.js force-directed skills network visualization
---

<div id="skills-network" class="visualization-container"></div>

<style>
  .visualization-container {
    width: 100%;
    height: 500px;
    background-color: #1a1a2e;
    border-radius: 0.5rem;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    position: relative;
    overflow: hidden;
  }

  :global(.node) {
    cursor: pointer;
    transition: opacity 0.3s;
  }

  :global(.node:hover) {
    opacity: 1 !important;
  }

  :global(.node-label) {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 12px;
    font-weight: 600;
    pointer-events: none;
    user-select: none;
  }

  :global(.link) {
    stroke: #4a5568;
    stroke-opacity: 0.4;
    stroke-width: 1.5px;
  }

  @media (max-width: 768px) {
    .visualization-container {
      height: 400px;
    }
  }
</style>

<script>
  import * as d3 from 'd3';

  // Define types for our data structures
  interface SkillNode {
    id: string;
    label: string;
    category: 'frontend' | 'backend' | 'tools';
    size: number;
    x?: number;
    y?: number;
    fx?: number | null;
    fy?: number | null;
  }

  interface SkillLink {
    source: string | SkillNode;
    target: string | SkillNode;
  }

  // Skills data with categories and connections
  const skillsData: { nodes: SkillNode[]; links: SkillLink[] } = {
    nodes: [
      // Frontend
      { id: 'html', label: 'HTML', category: 'frontend', size: 20 },
      { id: 'css', label: 'CSS', category: 'frontend', size: 20 },
      { id: 'javascript', label: 'JavaScript', category: 'frontend', size: 25 },
      { id: 'typescript', label: 'TypeScript', category: 'frontend', size: 24 },
      { id: 'react', label: 'React', category: 'frontend', size: 22 },
      { id: 'astro', label: 'Astro', category: 'frontend', size: 18 },
      
      // Backend
      { id: 'nodejs', label: 'Node.js', category: 'backend', size: 22 },
      { id: 'python', label: 'Python', category: 'backend', size: 23 },
      { id: 'api', label: 'REST APIs', category: 'backend', size: 20 },
      { id: 'database', label: 'Databases', category: 'backend', size: 21 },
      
      // Tools
      { id: 'git', label: 'Git', category: 'tools', size: 20 },
      { id: 'github', label: 'GitHub', category: 'tools', size: 19 },
      { id: 'docker', label: 'Docker', category: 'tools', size: 18 },
      { id: 'cicd', label: 'CI/CD', category: 'tools', size: 17 },
      { id: 'd3', label: 'D3.js', category: 'frontend', size: 16 },
    ],
    links: [
      // Frontend connections
      { source: 'html', target: 'css' },
      { source: 'css', target: 'javascript' },
      { source: 'javascript', target: 'typescript' },
      { source: 'typescript', target: 'react' },
      { source: 'typescript', target: 'astro' },
      { source: 'javascript', target: 'd3' },
      
      // Backend connections
      { source: 'javascript', target: 'nodejs' },
      { source: 'nodejs', target: 'api' },
      { source: 'python', target: 'api' },
      { source: 'api', target: 'database' },
      
      // Cross-category connections
      { source: 'react', target: 'nodejs' },
      { source: 'astro', target: 'html' },
      { source: 'astro', target: 'css' },
      
      // Tools connections
      { source: 'git', target: 'github' },
      { source: 'github', target: 'cicd' },
      { source: 'docker', target: 'cicd' },
      { source: 'nodejs', target: 'docker' },
      { source: 'python', target: 'docker' },
    ]
  };

  // Color scheme for different categories
  const categoryColors: Record<string, string> = {
    frontend: '#667eea',
    backend: '#f59e0b',
    tools: '#10b981'
  };

  function initVisualization() {
    const container = document.getElementById('skills-network');
    if (!container) return;

    // Clear any existing SVG
    d3.select(container).selectAll('*').remove();

    const width = container.clientWidth;
    const height = container.clientHeight;

    // Create SVG
    const svg = d3.select(container)
      .append('svg')
      .attr('width', width)
      .attr('height', height)
      .attr('viewBox', [0, 0, width, height])
      .attr('style', 'max-width: 100%; height: auto;');

    // Create a group for zoom
    const g = svg.append('g');

    // Add zoom behavior
    const zoom = d3.zoom()
      .scaleExtent([0.5, 3])
      .on('zoom', (event: d3.D3ZoomEvent<SVGSVGElement, unknown>) => {
        g.attr('transform', event.transform.toString());
      });

    svg.call(zoom as any);

    // Create force simulation
    const simulation = d3.forceSimulation(skillsData.nodes)
      .force('link', d3.forceLink(skillsData.links)
        .id((d: any) => d.id)
        .distance(80))
      .force('charge', d3.forceManyBody().strength(-300))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide().radius((d: any) => d.size + 5));

    // Create links
    const link = g.append('g')
      .selectAll('line')
      .data(skillsData.links)
      .join('line')
      .attr('class', 'link');

    // Create nodes
    const node = g.append('g')
      .selectAll('g')
      .data(skillsData.nodes)
      .join('g')
      .attr('class', 'node')
      .call(drag(simulation) as any);

    // Add circles to nodes
    node.append('circle')
      .attr('r', (d: SkillNode) => d.size)
      .attr('fill', (d: SkillNode) => categoryColors[d.category])
      .attr('stroke', '#fff')
      .attr('stroke-width', 2);

    // Add labels to nodes
    node.append('text')
      .attr('class', 'node-label')
      .attr('text-anchor', 'middle')
      .attr('dy', (d: SkillNode) => d.size + 15)
      .attr('fill', '#fff')
      .text((d: SkillNode) => d.label);

    // Add hover effects
    node.on('mouseenter', function(_event: any, d: SkillNode) {
      // Highlight connected nodes
      const connectedNodes = new Set<string>();
      skillsData.links.forEach(link => {
        const source = typeof link.source === 'string' ? link.source : link.source.id;
        const target = typeof link.target === 'string' ? link.target : link.target.id;
        if (source === d.id) connectedNodes.add(target);
        if (target === d.id) connectedNodes.add(source);
      });

      node.style('opacity', (n: SkillNode) => 
        n.id === d.id || connectedNodes.has(n.id) ? 1 : 0.3
      );

      link.style('stroke-opacity', (l: any) => {
        const source = typeof l.source === 'string' ? l.source : l.source.id;
        const target = typeof l.target === 'string' ? l.target : l.target.id;
        return source === d.id || target === d.id ? 0.8 : 0.1;
      });
    });

    node.on('mouseleave', function() {
      node.style('opacity', 1);
      link.style('stroke-opacity', 0.4);
    });

    // Update positions on simulation tick
    simulation.on('tick', () => {
      link
        .attr('x1', (d: any) => d.source.x)
        .attr('y1', (d: any) => d.source.y)
        .attr('x2', (d: any) => d.target.x)
        .attr('y2', (d: any) => d.target.y);

      node.attr('transform', (d: SkillNode) => `translate(${d.x},${d.y})`);
    });

    // Drag behavior
    function drag(simulation: d3.Simulation<SkillNode, undefined>) {
      function dragstarted(event: d3.D3DragEvent<SVGGElement, SkillNode, SkillNode>) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        event.subject.fx = event.subject.x;
        event.subject.fy = event.subject.y;
      }

      function dragged(event: d3.D3DragEvent<SVGGElement, SkillNode, SkillNode>) {
        event.subject.fx = event.x;
        event.subject.fy = event.y;
      }

      function dragended(event: d3.D3DragEvent<SVGGElement, SkillNode, SkillNode>) {
        if (!event.active) simulation.alphaTarget(0);
        event.subject.fx = null;
        event.subject.fy = null;
      }

      return d3.drag<SVGGElement, SkillNode>()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended);
    }
  }

  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initVisualization);
  } else {
    initVisualization();
  }

  // Reinitialize on window resize
  let resizeTimer: ReturnType<typeof setTimeout>;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(initVisualization, 250);
  });
</script>
